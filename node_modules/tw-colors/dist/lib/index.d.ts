import * as tailwindcss_types_config from 'tailwindcss/types/config';

declare const SCHEME: unique symbol;
type NestedColors = {
    [SCHEME]?: 'light' | 'dark';
} & MaybeNested<string, string>;
type TwcObjectConfig<ThemeName extends string> = Record<ThemeName, NestedColors>;
type TwcFunctionConfig<ThemeName extends string> = (scheme: {
    light: typeof light;
    dark: typeof dark;
}) => TwcObjectConfig<ThemeName>;
type TwcConfig<ThemeName extends string> = TwcObjectConfig<ThemeName> | TwcFunctionConfig<ThemeName>;
interface TwcOptions<ThemeName extends string> {
    getCssVariable?: (colorName: string) => string;
    getThemeClassName?: (themeName: ThemeName) => string;
    defaultTheme?: NoInfer<ThemeName>;
}
declare const resolveTwcConfig: <ThemeName extends string>(config?: TwcConfig<ThemeName>, { getCssVariable, getThemeClassName, defaultTheme, }?: TwcOptions<ThemeName>) => {
    variants: {
        name: string;
        definition: string[];
    }[];
    utilities: Record<string, Record<string, string>>;
    colors: Record<string, ({ opacityValue, opacityVariable, }: {
        opacityValue: string;
        opacityVariable: string;
    }) => string>;
};
declare const createThemes: <ThemeName extends string>(config?: TwcConfig<ThemeName>, options?: TwcOptions<ThemeName>) => {
    handler: tailwindcss_types_config.PluginCreator;
    config?: Partial<tailwindcss_types_config.Config> | undefined;
};
declare function dark(colors: NestedColors): {
    [SCHEME]: 'dark';
} & MaybeNested<string, string>;
declare function light(colors: NestedColors): {
    [SCHEME]: 'light';
} & MaybeNested<string, string>;
interface MaybeNested<K extends keyof any = string, V extends string = string> {
    [key: string]: V | MaybeNested<K, V>;
}
type NoInfer<T> = [T][T extends any ? 0 : never];

export { TwcConfig, TwcOptions, createThemes, resolveTwcConfig };
